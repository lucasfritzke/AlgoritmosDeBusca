"""JogoDaVelhaAlphaBeta.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Rf2pOT4F3y_paRh_1fDb276npspIMLhs
"""



"""# **Busca Competitiva**
## **Jogo da Velha**


---

O Jogo da Velha é um clássico jogo de tabuleiro para dois jogadores. O objetivo é ser o primeiro a alinhar três de suas próprias marcas (X ou O) horizontalmente, verticalmente ou diagonalmente em um tabuleiro 3x3
<br> <br>

**Estado inicial:** Um tabuleiro 3x3 vazio
<br> <br>
**Estado objeto:** Um tabuleiro preenchido onde um jogador tenha três marcas alinhadas (vitória)


"""

import numpy as np

matriz = np.array(
    [["-", "-", "-"],
     ["-", "-", "-"],
     ["-", "-", "-"]
     ]
)
# Quando o jogador digita o posição escolhida, a partir da tupla será convertido para posição na matriz
posicoes = {
    "1A": (0, 0), "1B": (0, 1), "1C": (0, 2),
    "2A": (1, 0), "2B": (1, 1), "2C": (1, 2),
    "3A": (2, 0), "3B": (2, 1), "3C": (2, 2)
}

def imprimir_Matriz():
    imprimir = "    A   B   C \n 1  "
    for i in range(len(matriz)):
        for j in range(len(matriz[0])):
            if j == 0 or j == 1:
                imprimir += matriz[i][j]
                imprimir += " | "
            else:
                imprimir += matriz[i][j]
        if i == 0 or i == 1:
            imprimir += f"\n   -----------\n {i + 2}  "
    print(imprimir)

def verificarVitoria():

    # O método em caso de vitoria retorna  X ou O
    for i in range(3):
        # Verificar linhas
        if all(matriz[i][j] == matriz[i][0] and matriz[i][j] != '-' for j in range(3)):
            return matriz[i][0]
        # Verificar colunas
        if all(matriz[j][i] == matriz[0][i] and matriz[j][i] != '-' for j in range(3)):
            return matriz[0][i]

    # Verificar diagonais
    if all(matriz[i][i] == matriz[0][0] and matriz[i][i] != '-' for i in range(3)):
        return matriz[0][0]
    if all(matriz[i][2 - i] == matriz[0][2] and matriz[i][2 - i] != '-' for i in range(3)):
        return matriz[0][2]

    return None  # Nenhum vencedor ainda

def verificarEmpate():
    return all(matriz[i][j] != '-' for i in range(3) for j in range(3))

"""# **Algoritmo minimax**


---
Considerando o estado atual do jogo, isto é, as posições selecionadas por cada jogador até o momento (X e O)  e as vazias ( - ), o algoritmo vai testar todas as possibilidades de jogo. Por exemplo:

| x  | -- | O | <br>
| -- |  x | -- | <br>
| x  | -- | O | <br>

<br>

Neste Caso temos 4 posições diponiveis. Combinando todas as posições possíveis temos **4!** ( 4x3x2x1=24). Logo existema 24 possibilidades de jogo. E a árvore de jogo poderá ter até 4 níveis.

# **Poda Alpha-Beta**


---

A poda alpha-beta é uma técnica de otimização utilizada no algoritmo Minimax, que é empregado em jogos de dois jogadores (como o jogo da velha) para determinar a melhor jogada. O objetivo da poda alpha-beta é reduzir o número de nós que precisam ser avaliados no espaço de busca, mantendo a mesma decisão final que o algoritmo Minimax sem poda.






"""

def movimentos_possiveis():
    return [(i, j) for i in range(3) for j in range(3) if matriz[i][j] == '-']

def minimax_alpha_beta(maximizando, alpha, beta):
    vencedor = verificarVitoria()
    if vencedor == "X":
        return -1  # Jogador vence
    elif vencedor == "O":
        return 1  # IA vence
    elif verificarEmpate():
        return 0  # Empate

    if maximizando:
        melhor_valor = -float('inf')
        for movimento in movimentos_possiveis():
            i, j = movimento
            matriz[i][j] = "O"  # Jogada da IA
            valor = minimax_alpha_beta(False, alpha, beta)  # Chamada recursiva
            matriz[i][j] = "-"  # Desfaz a jogada
            melhor_valor = max(melhor_valor, valor)
            alpha = max(alpha, valor)
            if beta <= alpha:
                break
        return melhor_valor
    else:
        melhor_valor = float('inf')
        for movimento in movimentos_possiveis():
            i, j = movimento
            matriz[i][j] = "X"  # Jogada do jogador
            valor = minimax_alpha_beta(True, alpha, beta)  # Chamada recursiva
            matriz[i][j] = "-"  # Desfaz a jogada
            melhor_valor = min(melhor_valor, valor)
            beta = min(beta, valor)
            if beta <= alpha:
                break
        return melhor_valor

def encontrar_melhor_jogada():
    melhor_valor = -float('inf')
    melhor_movimento = None

    for movimento in movimentos_possiveis():
        i, j = movimento
        matriz[i][j] = "O"
        valor = minimax_alpha_beta(False, -float('inf'), float('inf'))
        matriz[i][j] = "-"

        if valor > melhor_valor:
            melhor_valor = valor
            melhor_movimento = movimento

    return melhor_movimento

"""## **Implementação Humano (x) vs IA (O)**"""

def jogada_ia():
    melhor_movimento = encontrar_melhor_jogada()
    i, j = melhor_movimento
    matriz[i][j] = "O"
    if verificarVitoria() == "O":
          imprimir_Matriz()
          print("IA venceu!")
          return True
    return False


def jogada_humano():

    imprimir_Matriz()
    posicao_digitada = input("Jogar X -> Digite a posição que deseja jogar: ")
    # Busca a posição da matriz na tupla
    pos = posicoes.get(posicao_digitada)

    # Se a posição exitir
    if pos is not None:
        linha, coluna = pos
        # Verifia se está vazia
        if matriz[linha][coluna] == "-":
            matriz[linha][coluna] = "X"
            # Verifica se ganhou
            if verificarVitoria() == "X":
                imprimir_Matriz()
                print("Jogador Ganhou!")
                return True
        else:
            print("Posição já utilizada")
            jogada_humano()
    else:
        print("Posição inválida")
        jogada_humano()
    return verificarEmpate()

def jogar():
    #Flag controla o jogo para parar quando houver vitório ou empate
    # Enquanto false o jogo continua
    flag = False
    while flag != True:

        flag = jogada_humano()
        if verificarEmpate():
          print("Deu Velha!!!")
          break
        flag = jogada_ia()
        if verificarEmpate():
          print("Deu Velha!!!")
          break
        if flag is True:
          break
    return 0


def main():
    print("Digite a posição que deseja jogar Ex: A1, B3, C2 .... \n")
    jogar()

if __name__ == "__main__":
    main()